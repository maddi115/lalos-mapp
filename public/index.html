<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>HUD Map ‚Äî 1-mile</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css"/>
<script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
<link rel="icon" href="data:,">
<style>
:root{--bg:#fff}*{box-sizing:border-box}html,body,#gl{height:100%;width:100%;margin:0}
html,body{overflow:hidden;background:var(--bg);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial}
#gl{position:fixed;inset:0}
#ui{position:fixed;left:50%;bottom:12px;transform:translateX(-50%);z-index:2147483647;width:560px;max-width:92vw;color:#e5e7eb;background: #00000026;border-radius:14px;
padding:12px;display:flex;flex-direction:column;gap:10px}
#ui.compact{width:auto;max-width:none;padding:8px 10px;border-radius:12px}
.row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.input,.btn,.tag{padding:10px 12px;border:0;border-radius:10px;background:#0a0a0a;color:#e5e7eb;outline:0}
.input{flex:1;min-width:200px}.input::placeholder{color:#9aa3ad}.input.tiny{padding:6px 8px;min-width:120px;font-size:12px}
.btn{cursor:pointer}.btn:hover{background:#111}.btn[disabled]{opacity:.5;cursor:not-allowed}
.btn.link{background:transparent;padding:6px 8px;border-radius:8px;opacity:.8}.btn.link:hover{background:#0a0a0a;opacity:1}
.tag{font:600 12px/1 Inter;border-radius:999px}.help{font:600 12px/1.2 Inter;opacity:.9}.crosshair{cursor:crosshair!important}
.hide{display:none!important}
#note{position:fixed;top:10px;left:10px;background:#000;color:#fff;padding:6px 8px;border-radius:8px;font:600 12px/1 Inter;opacity:.9}
</style>
</head>
<body>
<div id="gl"></div><div id="note" class="hide">loading‚Ä¶</div>

<div id="ui" role="region" aria-label="Controls">
  <div class="row" id="topRow"><span id="locState" class="tag">Location: ‚Äî</span><span id="hint" class="help hide" aria-live="polite">Click ‚ÄúUse my location‚Äù to enable 1-mile ring</span></div>
  <div id="step1" class="row"><span class="tag">1/3</span><button id="doLoc" class="btn">üìç Use my location</button></div>
  <div id="step2" class="row hide"><span class="tag">2/3</span><span class="tag hide" id="placeTip">go on map and place inside radius</span><button id="placeHere" class="btn hide">Place here</button></div>
  <div id="step3" class="row hide"><span class="tag">3/3</span><button id="pick" class="btn">Upload image</button><button id="done" class="btn hide">‚úì Done</button></div>
  <div id="step3x" class="row hide"><span class="tag">Size: <span id="curPx">8px</span> / 349px</span><span class="tag" id="rate">rate: 1.35√ó</span></div>
  <div id="mini" class="row hide" aria-label="Compact"><span class="tag">Size: <span id="miniPx">8px</span> / 349px</span><input id="miniCmt" class="input tiny" type="text" maxlength="15" placeholder="comment‚Ä¶"/><button id="expand" class="btn" aria-label="Expand controls">‚ãØ</button></div>
  <input id="file" type="file" accept="image/*" style="display:none"/>
</div>

<script>
"use strict";

const App = {
    C: { // Constants
        MOBI: /Mobi|Android|iPhone|iPad|iPod|Windows Phone/i.test(navigator.userAgent),
        START: [-118.258683, 34.017235], ZREF: 16, MINPX: 8, MAXPX: 349, GOAL: 229 * 60 * 1000, SPEED: 1.35,
        RAD_M: 1609.344, D2R: Math.PI / 180, E111: 111320, API: "http://localhost:3000", LS_ID: "lm_postId", LS_CMT: "lm_comment", LS_DEV: "lm_deviceId",
        MAX_CMT: 15, SAVE_IVL: 5000, SAVE_DPX: 4,
        SID: "s", LID: "l", GIMG: "g", GBOX: "gb", RADS: "rad", RADF: "radf", RADL: "radl",
        FALLBACK_STYLE: {version:8, name:"OSM", sources:{osm:{type:"raster", tiles:["https://tile.openstreetmap.org/{z}/{x}/{y}.png"], tileSize:256}}, layers:[{id:"osm", type:"raster", source:"osm"}]},
    },

    S: { // State
        map: null, anchor: null, userCenter: null, youMarker: null, step: 1,
        imgURL: "", mediaReady: 0, natW: 0, natH: 0, baseW: 0, baseH: 0, geoW: 0, geoH: 0,
        commentText: "", domCmt: null, gifCanvas: null, gifCtx: null, gifRAF: 0,
        tAct: 0, tickTimer: 0, lastPxSaved: 0, lastPxAt: 0,
        savedId: "", deviceId: "",
        notFoundURLs: new Set(), globalState: new Map(), globalTimer: 0, NO_FEED: false,
        placeCleanup: () => {},
    },

    Util: {
        clamp: (x, a, b) => Math.max(a, Math.min(b, x)),
        getQS: (k) => new URL(location.href).searchParams.get(k),
        j: (u, o) => fetch(u, o).then(async r => { if (!r.ok) { let b = ""; try { b = await r.text() } catch {}; throw new Error(`${r.status} ${r.statusText}${b ? ` | ${b}` : ""}`) } return r.json() }),
        deb: (f, ms) => { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => f(...a), ms) } },
        headOK: async (u) => { try { const r = await fetch(u, { method: 'HEAD', cache: 'no-store' }); return r.ok } catch { return false } },
    },

    Dom: {
        $: (id) => document.getElementById(id),
        on: (e, t, f) => e && e.addEventListener(t, f),
        sh: (id, b) => App.Dom.$(id)?.classList.toggle("hide", !b),
        note: (t, show=true) => { const n = App.Dom.$("note"); if (n) { n.textContent = t; App.Dom.sh("note", show) } },
    },

    Geo: {
        off: (lng, lat, dx, dy) => ({ lng: lng + dx / (App.C.E111 * Math.cos(lat * App.C.D2R) || 1e-9), lat: lat + dy / App.C.E111 }),
        quad: (lng, lat, w, h) => { const tl = App.Geo.off(lng, lat, -w/2, +h/2), tr = App.Geo.off(lng, lat, +w/2, +h/2), br = App.Geo.off(lng, lat, +w/2, -h/2), bl = App.Geo.off(lng, lat, -w/2, -h/2); return [[tl.lng, tl.lat], [tr.lng, tr.lat], [br.lng, br.lat], [bl.lng, bl.lat]] },
        hav: (a, b, c, d) => { const R = 6371000, p1 = b * App.C.D2R, p2 = d * App.C.D2R, dp = (d - b) * App.C.D2R, dl = (c - a) * App.C.D2R, x = Math.sin(dp/2)**2 + Math.cos(p1) * Math.cos(p2) * Math.sin(dl/2)**2; return 2 * R * Math.asin(Math.sqrt(x)) },
        inside: (lng, lat) => App.S.userCenter ? App.Geo.hav(lng, lat, App.S.userCenter.lng, App.S.userCenter.lat) <= App.C.RAD_M : false,
        near: (a, b) => App.S.anchor ? App.Geo.hav(a, b, App.S.anchor.lng, App.S.anchor.lat) <= 3 : false,
    },

    MapFns: {
        rm: (id, isLayer=true) => { try { if (isLayer ? App.S.map.getLayer(id) : App.S.map.getSource(id)) { isLayer ? App.S.map.removeLayer(id) : App.S.map.removeSource(id) } } catch {} },
        mpp: (lng, lat) => { const p = App.S.map.project([lng, lat]), x = App.S.map.unproject([p.x + 1, p.y]), y = App.S.map.unproject([p.x, p.y + 1]); return { x: Math.abs((x.lng - lng) * (App.C.E111 * Math.cos(lat * App.C.D2R) || 1e-9)), y: Math.abs((y.lat - lat) * App.C.E111) } },
        drawRad: () => { if (!App.S.userCenter) return; const {lng, lat} = App.S.userCenter, r = App.C.RAD_M; const circle = { type: "Feature", geometry: { type: "Polygon", coordinates: [Array.from({ length: 97 }, (_, i) => { const ang = i/96*2*Math.PI, p = App.Geo.off(lng, lat, Math.cos(ang)*r, Math.sin(ang)*r); return [p.lng, p.lat] })]}}; if (!App.S.map.getSource(App.C.RADS)) { App.S.map.addSource(App.C.RADS, { type: "geojson", data: circle }); App.S.map.addLayer({ id: App.C.RADF, type: "fill", source: App.C.RADS, paint: { "fill-color": "#2b2b2b", "fill-opacity": 0.02 } }); App.S.map.addLayer({ id: App.C.RADL, type: "line", source: App.C.RADS, paint: { "line-color": "#2b2b2b", "line-width": 2, "line-opacity": 0.08 } }); } else App.S.map.getSource(App.C.RADS).setData(circle) },
        ghostAt: (lng, lat) => { if (!App.S.userCenter) { App.UIFns.setHint("Click ‚ÄúUse my location‚Äù first"); App.MapFns.ghost(true); return; } if (!App.Geo.inside(lng, lat)) { if (App.S.step === 2) App.UIFns.setHint("place inside 1-mile radius"); App.MapFns.ghost(true); return; } const px = App.UIFns.curPx(); App.MediaFns.fit(px); const r = App.MapFns.mpp(lng, lat), s = Math.pow(2, App.S.map.getZoom() - App.C.ZREF), w = App.S.baseW * r.x * s, h = App.S.baseH * r.y * s, c = App.Geo.quad(lng, lat, w, h); const poly = { type: "Feature", geometry: { type: "Polygon", coordinates: [[...c, c[0]]] } }; if (!App.S.map.getSource(App.C.GBOX)) { App.S.map.addSource(App.C.GBOX, { type: "geojson", data: poly }); App.S.map.addLayer({ id: `${App.C.GBOX}f`, type: "fill", source: App.C.GBOX, paint: { "fill-color": "#1e90ff", "fill-opacity": .08 } }); App.S.map.addLayer({ id: `${App.C.GBOX}l`, type: "line", source: App.C.GBOX, paint: { "line-color": "#1e90ff", "line-width": 2 } }); } else App.S.map.getSource(App.C.GBOX).setData(poly); if (App.S.imgURL) { if (!App.S.map.getSource(App.C.GIMG)) { App.S.map.addSource(App.C.GIMG, { type: "image", url: App.S.imgURL, coordinates: c }); App.S.map.addLayer({ id: `${App.C.GIMG}l`, type: "raster", source: App.C.GIMG, paint: { "raster-opacity": .35, "raster-fade-duration": 0 } }); } else App.S.map.getSource(App.C.GIMG)?.setCoordinates?.(c) } },
        ghost: (b) => { if (!b) return; App.MapFns.rm(`${App.C.GIMG}l`); App.MapFns.rm(App.C.GIMG, false); App.MapFns.rm(`${App.C.GBOX}l`); App.MapFns.rm(`${App.C.GBOX}f`); App.MapFns.rm(App.C.GBOX, false) },
        startPlace: () => { try { App.S.placeCleanup() } catch {}; App.UIFns.setHint(App.C.MOBI ? "Pan map, then Place here" : "go on map and place inside radius"); const stop = () => { try { App.S.placeCleanup() } catch {} }; const place = (lng, lat) => { if (!App.Geo.inside(lng, lat)) return alert("Place inside your 1-mile radius."); stop(); App.S.anchor = { lng, lat }; App.MediaFns.fit(App.UIFns.curPx()); App.MediaFns.lockM(); if (App.MediaFns.hasMedia()) App.MediaFns.apply(); if (App.S.mediaReady) App.MediaFns.updStamp(); App.UIFns.updCmt(); App.UIFns.youAuto(); App.UIFns.stepShow(3) }; if (!App.C.MOBI) { const mv = e => App.MapFns.ghostAt(e.lngLat.lng, e.lngLat.lat); const ck = e => place(e.lngLat.lng, e.lngLat.lat); const key = e => e.key === "Escape" && stop(); App.S.map.getCanvas().classList.add("crosshair"); App.S.map.on("mousemove", mv); App.S.map.once("click", ck); document.addEventListener("keydown", key); App.S.placeCleanup = () => { App.S.map.getCanvas().classList.remove("crosshair"); App.S.map.off("mousemove", mv); document.removeEventListener("keydown", key); App.MapFns.ghost(true); App.UIFns.setHint("", false) }; } else { const follow = () => { const c = App.S.map.getCenter(); App.MapFns.ghostAt(c.lng, c.lat) }; App.S.map.on("move", follow); follow(); App.Dom.sh("placeHere", true); const placeNow = () => { const c = App.S.map.getCenter(); place(c.lng, c.lat); }; App.Dom.on(App.Dom.$("placeHere"), "click", placeNow); App.S.placeCleanup = () => { App.S.map.off("move", follow); App.Dom.sh("placeHere", false); App.MapFns.ghost(true); App.UIFns.setHint("", false) }; } },
    },

    MediaFns: {
        hasMedia: () => App.S.gifCanvas || App.S.imgURL,
        fit: px => { if (!App.S.natW || !App.S.natH) { App.S.baseW = App.S.baseH = px; return } const a = App.S.natW / App.S.natH; if (a >= 1) { App.S.baseW = px; App.S.baseH = Math.round(px / a) } else { App.S.baseH = px; App.S.baseW = Math.round(px * a) } },
        lockM: () => { const c = App.S.anchor || App.S.map.getCenter(), r = App.MapFns.mpp(c.lng, c.lat), s = Math.pow(2, App.S.map.getZoom() - App.C.ZREF); App.S.geoW = App.S.baseW * r.x * s; App.S.geoH = App.S.baseH * r.y * s },
        clear: () => { cancelAnimationFrame(App.S.gifRAF); App.S.gifRAF = 0; App.S.gifCanvas = App.S.gifCtx = null; App.MapFns.rm(App.C.LID); App.MapFns.rm(App.C.SID, false); App.S.mediaReady = 0; App.Dom.sh("step3x", false) },
        apply: () => { App.MediaFns.clear(); App.FeedFns.purgeGlobalsNearMine(); if (!App.S.anchor) return; const c = App.Geo.quad(App.S.anchor.lng, App.S.anchor.lat, App.S.geoW, App.S.geoH); const onApplied = () => { App.S.mediaReady = 1; App.UIFns.updCmt(); App.Dom.sh("step3x", true); App.UIFns.compactify(); App.UIFns.youAuto(); App.StateFns.saveOnce() }; if (App.S.gifCanvas) { App.S.map.addSource(App.C.SID, { type: "canvas", canvas: App.S.gifCanvas, coordinates: c, animate: true }); App.S.map.addLayer({ id: App.C.LID, type: "raster", source: App.C.SID, paint: { "raster-opacity": 1, "raster-fade-duration": 0 } }); onApplied(); } else { App.S.map.addSource(App.C.SID, { type: "image", url: App.S.imgURL, coordinates: c }); App.S.map.addLayer({ id: App.C.LID, type: "raster", source: App.C.SID, paint: { "raster-opacity": 1, "raster-fade-duration": 0 } }); onApplied(); } },
        updStamp: () => { const s = App.S.map.getSource(App.C.SID); if (s && App.S.anchor) s.setCoordinates?.(App.Geo.quad(App.S.anchor.lng, App.S.anchor.lat, App.S.geoW, App.S.geoH)) },
        setupGIF: src => { App.S.imgURL = src; const im = new Image(); im.crossOrigin = "anonymous"; im.onload = () => { App.S.natW = im.naturalWidth || 256; App.S.natH = im.naturalHeight || 256; const cap = 1024, s = Math.min(1, cap / Math.max(App.S.natW, App.S.natH)); App.S.gifCanvas = document.createElement("canvas"); App.S.gifCanvas.width = Math.max(1, Math.round(App.S.natW * s)); App.S.gifCanvas.height = Math.max(1, Math.round(App.S.natH * s)); App.S.gifCtx = App.S.gifCanvas.getContext("2d"); App.S.gifCanvas._img = im; if (!App.S.anchor) { App.UIFns.setHint("Place first"); return } const d = () => { if (!App.S.gifCanvas) return; App.S.gifCtx.clearRect(0, 0, App.S.gifCanvas.width, App.S.gifCanvas.height); App.S.gifCtx.drawImage(App.S.gifCanvas._img, 0, 0, App.S.gifCanvas.width, App.S.gifCanvas.height); App.S.map.triggerRepaint(); App.S.gifRAF = requestAnimationFrame(d) }; d(); App.MediaFns.apply() }; im.onerror = () => alert("Couldn't load GIF."); im.src = src },
        loadFile: async (f) => {
            if (!App.S.anchor) {
                App.UIFns.setHint("Place first");
                return;
            }
            try {
                const formData = new FormData();
                formData.append('file', f);

                const { url, mime } = await App.Util.j(`${App.C.API}/api/upload`, {
                    method: 'POST',
                    body: formData
                });

                if (mime === 'image/gif') {
                    App.MediaFns.setupGIF(url);
                    return;
                }
                App.S.imgURL = url;
                const im = new Image();
                im.crossOrigin = "anonymous";
                im.onload = () => {
                    App.S.natW = im.naturalWidth || 256;
                    App.S.natH = im.naturalHeight || 256;
                    App.MediaFns.apply();
                };
                im.onerror = () => alert("Couldn't load image.");
                im.src = url;
            } catch (e) {
                console.error(e);
                alert('Upload failed. Try again.');
            }
        },
    },

    UIFns: {
        curPx: () => Math.round(App.C.MINPX + (App.C.MAXPX - App.C.MINPX) * (1 - Math.pow(1 - Math.min(1, Math.max(0, App.S.tAct / App.C.GOAL)), 3))),
        tFromPx: px => { const y = App.Util.clamp((px - App.C.MINPX) / (App.C.MAXPX - App.C.MINPX), 0, 1); return App.Util.clamp((1 - Math.cbrt(1 - y)) * App.C.GOAL, 0, App.C.GOAL) },
        stepShow: n => { App.S.step = n; ["step1", "step2", "step3", "step3x", "placeHere", "placeTip"].forEach(id => App.Dom.sh(id, (id.startsWith(`step${n}`) || (n === 2 && ["placeHere", "placeTip"].includes(id))))); App.UIFns.setHint() },
        setHint: (text, show = true) => { const h = App.Dom.$("hint"); if (!h) return; if(text !== undefined) h.textContent = text; else h.textContent = "go on map and place inside radius"; App.Dom.sh("hint", show || (App.S.step === 2 && !App.C.MOBI)); },
        setLoc: t => { const e = App.Dom.$("locState"); if(e) e.textContent = t; },
        compactify: () => { App.Dom.sh("done", true); App.Dom.$("ui")?.classList.add("compact"); App.Dom.sh("mini", true); ["topRow", "step1", "step2", "step3", "step3x", "hint", "expand"].forEach(id => App.Dom.$(id)?.parentNode?.removeChild(App.Dom.$(id))) },
        updCmt: () => { App.S.commentText = (App.S.commentText || "").slice(0, App.C.MAX_CMT); const t = App.S.commentText.trim(); if (!t || !App.S.anchor) { App.S.domCmt?.remove(); App.S.domCmt = null; App.StateFns.lsCmt(""); App.UIFns.youAuto(); return } App.UIFns.hideYou(); if (!App.S.domCmt) { const el = document.createElement("div"); el.style.cssText = "font:700 12px/1.25 Inter;color:#111;background:rgba(255,255,255,.98);padding:4px 8px;border-radius:10px;border:1px solid rgba(0,0,0,.12);box-shadow:0 2px 8px rgba(0,0,0,.25);pointer-events:none;"; el.textContent = t; App.S.domCmt = new maplibregl.Marker({ element: el, anchor: "bottom" }).setLngLat([App.S.anchor.lng, App.S.anchor.lat]).addTo(App.S.map) } else App.S.domCmt.getElement().textContent = t; App.UIFns.refreshCmt(); App.StateFns.lsCmt(t) },
        refreshCmt: () => { if (!App.S.domCmt || !App.S.anchor) return; const latUp = App.S.anchor.lat + ((App.S.geoH / 2) + 6) / App.C.E111; App.S.domCmt.setLngLat([App.S.anchor.lng, latUp]); const tl = App.Geo.off(App.S.anchor.lng, App.S.anchor.lat, -App.S.geoW / 2, +App.S.geoH / 2), br = App.Geo.off(App.S.anchor.lng, App.S.anchor.lat, +App.S.geoW / 2, -App.S.geoH / 2); const p1 = App.S.map.project([tl.lng, tl.lat]), p2 = App.S.map.project([br.lng, br.lat]), h = Math.abs(p2.y - p1.y); App.S.domCmt.getElement().style.fontSize = `${Math.max(13, Math.min(64, h * 0.12)).toFixed(2)}px` },
        youPos: () => App.S.anchor ? [App.S.anchor.lng, App.S.anchor.lat + ((App.S.geoH / 2) + 10) / App.C.E111] : null,
        showYou: () => { if (!App.S.anchor) return; const p = App.UIFns.youPos(); if (!p) return; if (!App.S.youMarker) { const el = document.createElement("div"); el.textContent = "you"; el.style.cssText = "font:600 11px/1 Inter,system-ui;color:#111;background:#fff;padding:2px 6px;border-radius:999px;border:1px solid #ddd;box-shadow:0 1px 2px rgba(0,0,0,.06);pointer-events:none;"; App.S.youMarker = new maplibregl.Marker({ element: el, anchor: "bottom" }).setLngLat(p).addTo(App.S.map) } else App.S.youMarker.setLngLat(p) },
        hideYou: () => { App.S.youMarker?.remove(); App.S.youMarker = null },
        refreshYou: () => { if (App.S.youMarker && App.S.anchor) { const p = App.UIFns.youPos(); p && App.S.youMarker.setLngLat(p) } },
        youAuto: () => { (App.S.commentText.trim() ? App.UIFns.hideYou : App.UIFns.showYou)() },
        geoOnce: () => { App.UIFns.setLoc("Location: requesting‚Ä¶"); if (!("geolocation" in navigator)) return App.UIFns.setLoc("Location: unsupported"), alert("Geolocation not supported."); navigator.geolocation.getCurrentPosition(p => { const { longitude: lng, latitude: lat } = p.coords; App.S.userCenter = { lng, lat }; App.MapFns.drawRad(); App.UIFns.setLoc("location confirmed"); App.S.map.easeTo({ center: [lng, lat], zoom: 14, duration: 600 }); App.UIFns.stepShow(2); App.MapFns.startPlace() }, _ => { App.UIFns.setLoc("Location: denied/unavailable"); alert(window.isSecureContext || location.hostname === "localhost" ? "Couldn‚Äôt get location. Check site permissions." : "Use HTTPS or http://localhost") }, { enableHighAccuracy: true, timeout: 30000, maximumAge: 0 }); },
    },

    StateFns: {
        capCmt: v => ((v || "").slice(0, App.C.MAX_CMT).trim() || null),
        lsCmt: t => { const v = (t || "").trim(); v ? localStorage.setItem(App.C.LS_CMT, v) : localStorage.removeItem(App.C.LS_CMT) },
        save: async (fields) => { try { const cmt = fields?.comment !== undefined ? App.StateFns.capCmt(fields.comment) : App.StateFns.capCmt(App.S.commentText); if (!App.S.savedId) { if (!App.S.anchor || !App.MediaFns.hasMedia()) return; const body = { lng: App.S.anchor.lng, lat: App.S.anchor.lat, mediaType: App.S.gifCanvas ? 'gif' : 'img', url: (App.S.imgURL || null), comment: cmt, natSize: (App.S.natW && App.S.natH) ? { w: App.S.natW, h: App.S.natH } : null, pxAtPlace: fields?.pxAtPlace ?? App.UIFns.curPx(), userCenter: App.S.userCenter || null, deviceId: App.S.deviceId }; const r = await App.Util.j(`${App.C.API}/api/posts`, { method: "POST", headers: { "Content-Type": "application/json", "X-Device-Id": App.S.deviceId }, body: JSON.stringify(body) }); if (r?.id) { App.S.savedId = r.id; localStorage.setItem(App.C.LS_ID, App.S.savedId); App.FeedFns.purgeGlobalsNearMine(); } } else { const patch = { ...fields }; if (patch.comment !== undefined) patch.comment = App.StateFns.capCmt(patch.comment); const r = await fetch(`${App.C.API}/api/posts/${App.S.savedId}`, { method: "PATCH", headers: { "Content-Type": "application/json", "X-Device-Id": App.S.deviceId }, body: JSON.stringify(patch) }); if (r.status === 404) { App.S.savedId = ""; localStorage.removeItem(App.C.LS_ID); } } } catch (e) { console.error("save/update failed", e) } },
        maybeSaveSize: async (px) => { if (!App.S.anchor || !App.MediaFns.hasMedia()) return; const now = Date.now(); if (!App.S.savedId) { await App.StateFns.save({ pxAtPlace: Math.round(px) }); App.S.lastPxSaved = Math.round(px); App.S.lastPxAt = now; localStorage.setItem("lm_pxSaved", String(App.S.lastPxSaved)); return } if (Math.abs(px - (App.S.lastPxSaved || 0)) >= App.C.SAVE_DPX && (now - App.S.lastPxAt) >= App.C.SAVE_IVL) { await App.StateFns.save({ pxAtPlace: Math.round(px) }); App.S.lastPxSaved = Math.round(px); App.S.lastPxAt = now; localStorage.setItem("lm_pxSaved", String(App.S.lastPxSaved)); } },
        saveOnce: async () => { if (App.S.savedId || !App.S.anchor || !App.MediaFns.hasMedia()) return; await App.StateFns.save({ pxAtPlace: App.UIFns.curPx(), comment: App.StateFns.capCmt(App.S.commentText) }) },
        restore: async () => { if (App.Util.getQS('reset') === '1') { App.StateFns.clearClientState(true); return; } let p = null; try { const id = localStorage.getItem(App.C.LS_ID); if(id) p = await App.Util.j(`${App.C.API}/api/posts/${id}`).catch(()=>{}); if(!p) { const did = localStorage.getItem(App.C.LS_DEV); if(did) p = await App.Util.j(`${App.C.API}/api/posts/latest?deviceId=${encodeURIComponent(did)}`).catch(()=>{}); } if (!p) p = await App.Util.j(`${App.C.API}/api/posts/latest`).catch(()=>{}); if (p && (!Array.isArray(p.coordinates) || !p.url)) p=null; } catch {} if (!p) { App.StateFns.clearClientState(); return; } App.S.savedId = p.id; localStorage.setItem(App.C.LS_ID, App.S.savedId); App.S.anchor = { lng: p.coordinates[0], lat: p.coordinates[1] }; App.S.userCenter = p.userCenter || null; if (App.S.userCenter) App.MapFns.drawRad(); App.S.imgURL = p.url || ""; if (p.natSize) { App.S.natW = p.natSize.w; App.S.natH = p.natSize.h } const px = p.pxAtPlace || App.C.MINPX; App.S.tAct = App.UIFns.tFromPx(px); App.S.lastPxSaved = Math.round(px); localStorage.setItem("lm_pxSaved", String(App.S.lastPxSaved)); App.MediaFns.fit(px); App.MediaFns.lockM(); App.MediaFns.apply(); App.S.commentText = (p.comment ?? "").slice(0, App.C.MAX_CMT); App.StateFns.lsCmt(App.S.commentText); App.UIFns.updCmt(); App.UIFns.youAuto(); App.S.map.easeTo({ center: [App.S.anchor.lng, App.S.anchor.lat], zoom: 14, duration: 400 }); App.UIFns.stepShow(3); App.Dom.sh("step3x", true); App.UIFns.compactify(); },
        clearClientState: (isReset = false) => { App.S.NO_FEED = isReset; ["l", "s", `${App.C.GIMG}l`, App.C.GIMG, `${App.C.GBOX}l`, `${App.C.GBOX}f`, App.C.GBOX, App.C.RADL, App.C.RADF, App.C.RADS].forEach((id, i) => App.MapFns.rm(id, i % 2 === 0)); App.S.globalState.forEach(g => { try { g.layerId && App.MapFns.rm(g.layerId); g.srcId && App.MapFns.rm(g.srcId, false); g.marker?.remove?.() } catch {} }); App.S.globalState.clear(); App.S.domCmt?.remove(); App.S.youMarker?.remove(); App.S.domCmt = null; App.S.youMarker = null; App.S.commentText = ""; App.StateFns.lsCmt(""); App.S.imgURL = ""; App.S.mediaReady = 0; App.S.savedId = ""; localStorage.removeItem(App.C.LS_ID); App.S.lastPxSaved = 0; localStorage.removeItem("lm_pxSaved"); App.S.anchor = null; App.S.userCenter = null; App.UIFns.setLoc("Location: ‚Äî"); App.UIFns.setHint("Click ‚ÄúUse my location‚Äù to enable 1-mile ring", false); App.UIFns.stepShow(1); },
    },

    FeedFns: {
        purgeGlobalsNearMine: () => { if (!App.S.anchor) return; App.S.globalState.forEach((g, id) => { if (!g?.coords) return; if (App.Geo.near(g.coords[0], g.coords[1]) || (App.S.savedId && id === App.S.savedId)) App.FeedFns.removeGlobalId(id) }); },
        removeGlobalId: id => { const g = App.S.globalState.get(id); if (!g) return; try { App.MapFns.rm(g.layerId); App.MapFns.rm(g.srcId, false); g.marker?.remove?.() } catch {} App.S.globalState.delete(id); },
        upsertGlobalLabel: p => { const g = App.S.globalState.get(p.id) || {}; const t = (p.comment || "").slice(0, App.C.MAX_CMT).trim(); if (!t) { if (g.marker) { g.marker.remove(); g.marker = null } App.S.globalState.set(p.id, { ...g, marker: null }); return } const el = g.marker?.getElement?.() || (() => { const e = document.createElement("div"); e.style.cssText = "font:700 12px/1.25 Inter;color:#111;background:rgba(255,255,255,.98);padding:4px 8px;border-radius:10px;border:1px solid rgba(0,0,0,.12);box-shadow:0 2px 8px rgba(0,0,0,.25);pointer-events:none;"; return e })(); el.textContent = t; const mk = g.marker || new maplibregl.Marker({ element: el, anchor: "bottom" }).setLngLat([p.coordinates[0], p.coordinates[1]]).addTo(App.S.map); mk.setLngLat(p.coordinates); App.S.globalState.set(p.id, { ...g, marker: mk }); },
        upsertGlobalImage: async p => { if (!p.coordinates?.length) return; if ((App.S.savedId && p.id === App.S.savedId) || App.Geo.near(p.coordinates[0], p.coordinates[1])) return; if (p.url && App.S.notFoundURLs.has(p.url)) return; if (p.url && p.url.startsWith('/uploads/') && !(await App.Util.headOK(p.url))) { App.S.notFoundURLs.add(p.url); return } const [lng, lat] = p.coordinates, lid = `g-${p.id}`, sid = `${lid}-s`; const px = Math.max(App.C.MINPX, Math.min(App.C.MAXPX, +p.pxAtPlace || 160)), r = App.MapFns.mpp(lng, lat), s = Math.pow(2, App.S.map.getZoom() - App.C.ZREF); const coords = App.Geo.quad(lng, lat, px * r.x * s, px * r.y * s); if (!App.S.map.getSource(sid)) { App.S.map.addSource(sid, { type: 'image', url: p.url, coordinates: coords }); App.S.map.addLayer({ id: lid, type: 'raster', source: sid, paint: { 'raster-opacity': 0.98, 'raster-fade-duration': 0 } }); } else App.S.map.getSource(sid).setCoordinates(coords); const prev = App.S.globalState.get(p.id) || {}; App.S.globalState.set(p.id, { layerId: lid, srcId: sid, coords: [lng, lat], marker: prev.marker, lastSeen: Date.now() }); App.FeedFns.upsertGlobalLabel(p); },
        fetch: async () => { try { const c = App.S.map.getCenter(); const rows = await App.Util.j(`${App.C.API}/api/posts/near?lng=${c.lng}&lat=${c.lat}&radiusMeters=5000&limit=80`); rows.sort((a,b)=>new Date(b.createdAt||0)-new Date(a.createdAt||0)); for (const p of rows) if (p.url) await App.FeedFns.upsertGlobalImage(p) } catch {} },
        enable: () => { if (App.S.globalTimer) clearInterval(App.S.globalTimer); App.FeedFns.fetch(); App.S.globalTimer = setInterval(App.FeedFns.fetch, 2000) },
    },

    runDailyReset: () => {
        const now = new Date();
        const lastReset = Number(localStorage.getItem("lm_lastReset") || 0);
        const resetTime = new Date();
        resetTime.setHours(3, 0, 0, 0);
        if (now.getTime() >= resetTime.getTime() && lastReset < resetTime.getTime()) {
            ["lm_postId", "lm_comment", "lm_pxSaved"].forEach(k => localStorage.removeItem(k));
            localStorage.setItem("lm_lastReset", String(now.getTime()));
        }
    },

    tick: () => {
        if (App.S.tickTimer) return;
        let last = performance.now();
        App.S.tickTimer = setInterval(() => {
            const now = performance.now();
            App.S.tAct = Math.min(App.C.GOAL, App.S.tAct + (now - last) * App.C.SPEED);
            last = now;
            const px = App.UIFns.curPx();
            const curPxEl = App.Dom.$("curPx");
            const miniPxEl = App.Dom.$("miniPx");
            if (curPxEl) curPxEl.textContent = `${px}px`;
            if (miniPxEl) miniPxEl.textContent = `${px}px`;
            if (!App.S.anchor) return;
            App.MediaFns.fit(px);
            App.MediaFns.lockM();
            if (App.S.mediaReady) App.MediaFns.updStamp();
            App.UIFns.refreshCmt();
            App.UIFns.refreshYou();
            App.StateFns.maybeSaveSize(px);
        }, 1000);
    },

    wire: () => {
        App.Dom.on(App.Dom.$("pick"), "click", () => App.Dom.$("file")?.click());
        App.Dom.on(App.Dom.$("file"), "change", e => { const f = e.target.files?.[0]; if (f) App.MediaFns.loadFile(f); e.target.value = "" });
        App.Dom.on(App.Dom.$("expand"), "click", () => { App.Dom.$("ui")?.classList.remove("compact"); App.Dom.sh("mini", false); ["topRow", "step1", "step2", "step3", "step3x", "hint"].forEach(id=>App.Dom.sh(id, id!=="step3x"||App.S.step===3)); App.UIFns.stepShow(App.S.step); });
        App.Dom.on(App.Dom.$("done"), "click", App.UIFns.compactify);
        App.Dom.on(App.Dom.$("doLoc"), "click", App.UIFns.geoOnce);

        const saveCmt = App.Util.deb(async () => { App.StateFns.lsCmt(App.S.commentText); await App.StateFns.save({ comment: App.StateFns.capCmt(App.S.commentText) }) }, 400);
        App.Dom.on(App.Dom.$("miniCmt"), "input", () => { App.S.commentText = App.Dom.$("miniCmt").value.slice(0, App.C.MAX_CMT); App.UIFns.updCmt(); saveCmt(); });

        const flush = async () => { try { App.StateFns.lsCmt(App.S.commentText); if (!App.S.savedId) return; await fetch(`${App.C.API}/api/posts/${App.S.savedId}`, { method: "PATCH", keepalive: true, headers: { 'Content-Type': 'application/json', 'X-Device-Id': App.S.deviceId }, body: JSON.stringify({ comment: App.StateFns.capCmt(App.S.commentText), pxAtPlace: App.UIFns.curPx() }) }); localStorage.setItem("lm_pxSaved", String(App.UIFns.curPx())); } catch {} };
        document.addEventListener("visibilitychange", () => { if (document.visibilityState === 'hidden') flush() });
        window.addEventListener("pagehide", flush);
    },

    init: async () => {
        App.runDailyReset();
        App.S.deviceId = localStorage.getItem(App.C.LS_DEV) || (crypto.getRandomValues(new Uint32Array(4)).join('-'));
        localStorage.setItem(App.C.LS_DEV, App.S.deviceId);
        App.S.lastPxSaved = +localStorage.getItem("lm_pxSaved") || 0;

        if (window.maplibregl && typeof maplibregl.supported === "function" && !maplibregl.supported()) return App.Dom.note("WebGL disabled.");
        App.Dom.note("loading map‚Ä¶");
        let style = null; try { const r = await fetch("https://basemaps.cartocdn.com/gl/positron-gl-style/style.json", { mode: "cors" }); if (r.ok) style = await r.json() } catch {}
        App.S.map = new maplibregl.Map({ container: "gl", style: style || App.C.FALLBACK_STYLE, center: App.C.START, zoom: 11, dragRotate: false, pitchWithRotate: false, maxPitch: 0, renderWorldCopies: false, antialias: false, trackResize: true, fadeDuration: 0 });
        App.S.map.addControl(new maplibregl.NavigationControl({ showCompass: false }), "bottom-right");
        App.S.map.on("error", e => { console.error(e); App.Dom.note("map error (see console)") });
        App.S.map.on("move", () => { if(App.S.anchor){ App.UIFns.refreshCmt(); App.UIFns.refreshYou(); }});
        
        App.S.map.on("load", async () => {
            App.S.map.resize();
            App.Dom.note("", false);
            App.wire();
            App.UIFns.stepShow(1);
            App.Dom.$("doLoc").textContent="üìç Use my location";
            App.Dom.$("rate").textContent=`rate: ${App.C.SPEED}√ó`;
            App.UIFns.setLoc("allow location to show your 1-mile radius");
            navigator.permissions?.query?.({name:"geolocation"}).then(s=>{if(s.state==="denied"){App.UIFns.setHint("Location blocked. Allow it in site settings.")}}).catch(()=>{});
            
            App.tick();
            await App.StateFns.restore();
            if (!App.S.NO_FEED) App.FeedFns.enable();
        });
    },
};

App.init();
</script>
</body>
</html>